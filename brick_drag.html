<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Brick Breaker ‚Äî Mobile (Enhanced)</title>
  <style>
    :root {
      --bg: #0e1014;
      --fg: #e6e9ef;
      --accent: #6ee7ff;
      --accent-2: #a78bfa;
      --danger: #ff6b6b;
      --muted: #9aa1ac;
      --btn: rgba(255,255,255,.07);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: radial-gradient(1200px 800px at 70% 20%, #161a22, var(--bg));
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--fg);
      overflow: hidden;
      touch-action: none;
    }
    #wrap { position: relative; width: 100vw; height: 100vh; }
    canvas { display: block; width: 100%; height: 100%; touch-action: none; }
    .hud { position: absolute; inset: 0; pointer-events: none; padding: env(safe-area-inset-top) 12px 12px 12px; }
    .row { display: flex; justify-content: space-between; align-items: center; gap: 8px; }
    .chip { pointer-events: auto; display: inline-flex; align-items: center; gap: 8px; padding: 8px 12px; border-radius: 999px; background: rgba(255,255,255,0.06); backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); font-weight: 600; }
    .chip small { color: var(--muted); font-weight: 500; }
    .btn { pointer-events: auto; display: inline-flex; align-items: center; justify-content: center; padding: 10px 14px; border-radius: 10px; background: var(--btn); border: 1px solid rgba(255,255,255,.08); font-weight: 700; color: var(--fg); }
    .controls { position: absolute; left: 0; right: 0; bottom: 56px; display: flex; justify-content: space-between; gap: 12px; padding: 0 8px 8px 8px; }
    .ctrl { pointer-events: auto; width: 44vw; max-width: 360px; height: 20vh; min-height: 110px; background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.08); border-radius: 18px; backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); display: grid; place-items: center; color: var(--muted); font-weight: 800; letter-spacing: 1px; user-select: none; }
    .ctrl:active { background: rgba(255,255,255,0.09); }
    .overlay { position: absolute; inset: 0; display: grid; place-items: center; background: rgba(0,0,0,0.35); backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); }
    .card { width: min(92vw, 520px); background: #0f131a; border: 1px solid rgba(255,255,255,0.1); border-radius: 18px; padding: 18px; box-shadow: 0 10px 40px rgba(0,0,0,0.55); text-align: center; }
    .title { font-size: 24px; font-weight: 800; margin: 4px 0 10px; }
    .subtitle { color: var(--muted); margin-bottom: 14px; }
    .actions { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
    @media (min-width: 900px) and (orientation: landscape) { .controls { display:none; } }
  
    .drag-strip {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 8px;
      width: 70vw;
      max-width: 600px;
      height: 40px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      display: grid;
      place-items: center;
      color: var(--muted);
      font-weight: 800;
      letter-spacing: 0.5px;
      user-select: none;
      pointer-events: auto;
      touch-action: none;
      cursor: grab;
    }
    .drag-strip:active { background: rgba(255,255,255,0.10); cursor: grabbing; }

  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game"></canvas>
    <div class="hud">
      <div class="row">
        <div class="chip">Score&nbsp;<span id="score">0</span></div>
        <div class="row" style="gap:8px">
          <div class="chip"><small>Best</small>&nbsp;<span id="bestScore">0</span></div>
          <div class="chip"><small>Level</small>&nbsp;<span id="level">1</span></div>
          <div class="chip"><small>Lives</small>&nbsp;<span id="lives">3</span></div>
          <button class="btn" id="pauseBtn" aria-label="Pause or resume">‚è∏Ô∏é</button>
        </div>
      </div>
    </div>
    <div class="controls">
      <div class="ctrl" id="leftBtn">‚óÄÔ∏é</div>
      <div class="ctrl" id="rightBtn">‚ñ∂Ô∏é</div>
    </div>
    <div class="drag-strip" id="dragStrip">‚úã ÎìúÎûòÍ∑∏Ìï¥ÏÑú Ìå®Îì§ Ïù¥Îèô</div>
    <div class="overlay" id="startOverlay">
      <div class="card">
        <div class="title">Brick Breaker</div>
        <div class="subtitle">ÏÜêÍ∞ÄÎùΩ/ÎßàÏö∞Ïä§Î°ú Ìå®Îì§ÏùÑ <b>ÎìúÎûòÍ∑∏</b>ÌïòÏÑ∏Ïöî. ÌÉ≠ÌïòÎ©¥ Î∞úÏÇ¨Îê©ÎãàÎã§.<br/>Ï¢å/Ïö∞ Î≤ÑÌäºÎèÑ ÏßÄÏõêÌï©ÎãàÎã§.</div>
        <div class="actions">
          <button class="btn" id="startBtn">Start</button>
          <button class="btn" id="muteBtn">üîá Mute</button>
        </div>
      </div>
    </div>
    <div class="overlay" id="gameOver" style="display:none">
      <div class="card">
        <div class="title">Game Over</div>
        <div class="subtitle">Ï†êÏàò: <span id="finalScore">0</span> ¬∑ ÏµúÍ≥†Í∏∞Î°ù: <span id="finalBest">0</span></div>
        <div class="actions">
          <button class="btn" id="retryBtn">Retry</button>
          <button class="btn" id="shareBtn">Share</button>
        </div>
      </div>
    </div>
  </div>

  <script>
  // --- HiDPI Canvas Setup ---
  const DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const hud = {
    score: document.getElementById('score'),
    best: document.getElementById('bestScore'),
    level: document.getElementById('level'),
    lives: document.getElementById('lives'),
  };

  const startOverlay = document.getElementById('startOverlay');
  const gameOverOverlay = document.getElementById('gameOver');
  const finalScoreEl = document.getElementById('finalScore');
  const finalBestEl  = document.getElementById('finalBest');

  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const startBtn = document.getElementById('startBtn');
  const retryBtn = document.getElementById('retryBtn');
  const shareBtn = document.getElementById('shareBtn');
  const muteBtn = document.getElementById('muteBtn');

  let W = 0, H = 0, running = false, paused = false, muted = false;

  function resize() {
    W = Math.floor(window.innerWidth * DPR);
    H = Math.floor(window.innerHeight * DPR);
    canvas.width = W; canvas.height = H;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    layoutGame();
    draw();
  }
  window.addEventListener('resize', resize);

  // --- Persistent Score ---
  const STORAGE_KEY = 'bb_best_v1';
  function loadBest() {
    const v = Number(localStorage.getItem(STORAGE_KEY) || 0);
    hud.best.textContent = v;
    return v;
  }
  function saveBest(v) {
    localStorage.setItem(STORAGE_KEY, String(v));
    hud.best.textContent = v;
  }
  let bestScore = loadBest();

  // --- Game State ---
  const state = { score: 0, level: 1, lives: 3 };

  // Paddle
  const paddle = { w: 0, h: 0, x: 0, y: 0, speed: 0 };

  // Ball
  const ball = { r: 0, x: 0, y: 0, dx: 0, dy: 0, speed: 0, launched: false };

  // Bricks
  let bricks = [];
  const brickConf = { rows: 5, cols: 8, marginX: 18, marginY: 12, padTop: 90, padSide: 14, h: 18 };

  function layoutGame() {
    paddle.w = Math.max(110, Math.min(260, Math.floor(W * 0.18)));
    paddle.h = Math.floor(14 * DPR);
    paddle.x = (W - paddle.w) / 2;
    paddle.y = H - Math.floor(60 * DPR);
    paddle.speed = Math.floor(8 * DPR + state.level * 0.6);

    ball.r = Math.floor(7 * DPR);
    resetBall(false);

    const padSide = Math.floor(brickConf.padSide * DPR);
    const padTop = Math.floor(brickConf.padTop * DPR);
    const marginX = Math.floor(brickConf.marginX * DPR);
    const marginY = Math.floor(brickConf.marginY * DPR);
    const h = Math.floor(brickConf.h * DPR);

    const cols = Math.max(6, Math.min(11, brickConf.cols));
    const rows = Math.max(4, Math.min(9, brickConf.rows + (state.level>1 ? 1 : 0)));

    const totalMargin = (cols - 1) * marginX + padSide * 2;
    const w = Math.floor((W - totalMargin) / cols);

    bricks = [];
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        bricks.push({ x: padSide + c*(w+marginX), y: padTop + r*(h+marginY), w, h, hit:false, hp: 1 + Math.floor((state.level-1)/2) });
      }
    }
  }

  function resetBall(withLaunch = false) {
    ball.x = paddle.x + paddle.w/2;
    ball.y = paddle.y - 18 * DPR;
    const base = 4.0 + state.level * 0.25;
    const angle = (-Math.PI/3) + (Math.random() * Math.PI/6);
    ball.speed = base * DPR;
    ball.dx = Math.cos(angle) * ball.speed;
    ball.dy = Math.sin(angle) * ball.speed;
    ball.launched = withLaunch;
  }

  // --- INPUT: drag with touch/mouse OR use buttons ---
  let leftPressed = false, rightPressed = false, dragging = false;

  function movePaddleToClient(clientX) {
    const x = clientX * DPR - paddle.w/2;
    paddle.x = Math.max(0, Math.min(W - paddle.w, x));
    if (!ball.launched) ball.x = paddle.x + paddle.w/2;
  }

  // Pointer events cover mouse+touch
  function onPointerDown(e) { dragging = true; ball.launched = true; movePaddleToClient(e.clientX); }
  function onPointerMove(e) { if (dragging) movePaddleToClient(e.clientX); }
  function onPointerUp() { dragging = false; }
  canvas.addEventListener('pointerdown', onPointerDown);
  canvas.addEventListener('pointermove', onPointerMove);
  window.addEventListener('pointerup', onPointerUp);

  // Buttons (optional)
  leftBtn.addEventListener('touchstart', () => leftPressed = true, {passive:true});
  leftBtn.addEventListener('touchend',   () => leftPressed = false, {passive:true});
  rightBtn.addEventListener('touchstart', () => rightPressed = true, {passive:true});
  rightBtn.addEventListener('touchend',   () => rightPressed = false, {passive:true});

  window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'a') leftPressed = true;
    if (e.key === 'ArrowRight' || e.key === 'd') rightPressed = true;
    if (e.key === ' ') ball.launched = true;
  });
  window.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'a') leftPressed = false;
    if (e.key === 'ArrowRight' || e.key === 'd') rightPressed = false;
  });

  pauseBtn.addEventListener('click', () => { if (!running) return; paused = !paused; pauseBtn.textContent = paused ? '‚ñ∂Ô∏é' : '‚è∏Ô∏é'; });
  startBtn.addEventListener('click', startGame);
  retryBtn.addEventListener('click', () => { gameOverOverlay.style.display='none'; startGame(); });
  shareBtn.addEventListener('click', async () => {
    try {
      const text = `Brick Breaker ‚Äî Score ${state.score}, Level ${state.level}. Best ${bestScore}`;
      if (navigator.share) await navigator.share({title:'Brick Breaker', text});
      else await navigator.clipboard.writeText(text);
      alert('Shared / Copied!');
    } catch {}
  });
  muteBtn.addEventListener('click', () => { muted = !muted; muteBtn.textContent = muted ? 'üîá Mute' : 'üîä Sound'; });

  // --- WebAudio SFX (simple beeps) ---
  let audioCtx = null;
  function ensureAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
  function beep(freq=600, dur=0.05, type='sine', vol=0.2) {
    if (muted) return;
    try {
      ensureAudio();
      const t = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, t);
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(vol, t + 0.005);
      gain.gain.exponentialRampToValueAtTime(0.001, t + dur);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(t); osc.stop(t + dur + 0.02);
    } catch {}
  }

  function sfxWall() { beep(700, 0.03, 'square', 0.15); }
  function sfxBrick() { beep(520, 0.05, 'triangle', 0.2); }
  function sfxLose() { beep(200, 0.2, 'sawtooth', 0.25); }

  // --- Loop ---
  let lastTime = 0;
  function loop(ts) {
    if (!running) return;
    const dt = Math.min(32, ts - lastTime); lastTime = ts;
    if (!paused) update(dt/16.666);
    draw();
    requestAnimationFrame(loop);
  }

  function update(dt) {
    if (leftPressed) paddle.x = Math.max(0, paddle.x - paddle.speed * dt);
    if (rightPressed) paddle.x = Math.min(W - paddle.w, paddle.x + paddle.speed * dt);
    if (!ball.launched) ball.x = paddle.x + paddle.w/2;

    if (ball.launched) {
      ball.x += ball.dx * dt; ball.y += ball.dy * dt;

      // Walls
      if (ball.x < ball.r) { ball.x = ball.r; ball.dx *= -1; sfxWall(); }
      if (ball.x > W - ball.r) { ball.x = W - ball.r; ball.dx *= -1; sfxWall(); }
      if (ball.y < ball.r + 8*DPR) { ball.y = ball.r + 8*DPR; ball.dy *= -1; sfxWall(); }

      // Bottom
      if (ball.y > H + ball.r) {
        state.lives--; hud.lives.textContent = state.lives; sfxLose();
        if (state.lives <= 0) return endGame();
        resetBall(false);
      }

      // Paddle
      if (ball.y + ball.r >= paddle.y && ball.y - ball.r <= paddle.y + paddle.h && ball.x >= paddle.x && ball.x <= paddle.x + paddle.w && ball.dy > 0) {
        ball.y = paddle.y - ball.r;
        const hitPos = (ball.x - paddle.x) / paddle.w; // 0..1
        const angle = (Math.PI * 0.75) * (hitPos - 0.5);
        const spd = Math.min(12*DPR, Math.hypot(ball.dx, ball.dy) * 1.03 + 0.2*DPR);
        ball.dx = Math.sin(angle) * spd;
        ball.dy = -Math.cos(angle) * spd;
        sfxWall();
      }

      // Bricks
      for (const br of bricks) {
        if (br.hit) continue;
        if (ball.x + ball.r < br.x || ball.x - ball.r > br.x + br.w || ball.y + ball.r < br.y || ball.y - ball.r > br.y + br.h) continue;
        const overlapX = Math.min(ball.x + ball.r - br.x, br.x + br.w - (ball.x - ball.r));
        const overlapY = Math.min(ball.y + ball.r - br.y, br.y + br.h - (ball.y - ball.r));
        if (overlapX < overlapY) { ball.dx *= -1; } else { ball.dy *= -1; }
        br.hp--; if (br.hp <= 0) { br.hit = true; state.score += 10; hud.score.textContent = state.score; sfxBrick(); }
        break;
      }

      // Next level
      if (bricks.every(b => b.hit)) {
        state.level++; hud.level.textContent = state.level;
        layoutGame();
        resetBall(false);
      }
    }
  }

  function draw() {
    ctx.clearRect(0,0,W,H);
    // Background grid
    ctx.save();
    const g = 24 * DPR; ctx.strokeStyle = 'rgba(255,255,255,0.04)'; ctx.lineWidth = 1;
    ctx.beginPath();
    for (let x = 0; x < W; x += g) { ctx.moveTo(x, 0); ctx.lineTo(x, H); }
    for (let y = 0; y < H; y += g) { ctx.moveTo(0, y); ctx.lineTo(W, y); }
    ctx.stroke();
    ctx.restore();

    // Paddle
    roundRect(ctx, paddle.x, paddle.y, paddle.w, paddle.h, 8*DPR, '#1f2937', '#94a3b8');
    // Ball
    ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
    const grad = ctx.createRadialGradient(ball.x - ball.r/2, ball.y - ball.r/2, ball.r/3, ball.x, ball.y, ball.r);
    grad.addColorStop(0, '#ffffff'); grad.addColorStop(1, '#6ee7ff');
    ctx.fillStyle = grad; ctx.fill();
    // Bricks
    for (const br of bricks) {
      if (br.hit) continue;
      const c1 = `hsl(${200 + (br.y%120)}, 80%, 62%)`;
      roundRect(ctx, br.x, br.y, br.w, br.h, 6*DPR, 'rgba(255,255,255,0.08)', c1);
    }
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    if (fill) { ctx.fillStyle = fill; ctx.fill(); }
    if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = 2; ctx.stroke(); }
  }

  function endGame() {
    running = false;
    finalScoreEl.textContent = state.score;
    if (state.score > bestScore) { bestScore = state.score; saveBest(bestScore); }
    finalBestEl.textContent = bestScore;
    gameOverOverlay.style.display = 'grid';
  }

  function startGame() {
    // Resume audio context on user gesture
    try { if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); } catch {}
    state.score = 0; state.level = 1; state.lives = 3;
    hud.score.textContent = 0; hud.level.textContent = 1; hud.lives.textContent = 3;
    startOverlay.style.display = 'none'; gameOverOverlay.style.display='none';
    resize();
    running = true; paused = false; pauseBtn.textContent = '‚è∏Ô∏é';
    lastTime = performance.now();
    requestAnimationFrame(loop);
  }

  // Init
  resize();
  startOverlay.addEventListener('click', (e) => { if (e.target === startOverlay) startGame(); });
  document.addEventListener('touchmove', (e) => { if (e.target === canvas) e.preventDefault(); }, {passive:false});
  // --- Drag Strip (hand handle) ---
  const dragStrip = document.getElementById('dragStrip');
  let stripDragging = false;

  function movePaddleWithStrip(clientX) {
    const rect = dragStrip.getBoundingClientRect();
    const ratio = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
    paddle.x = (W - paddle.w) * ratio;
    if (!ball.launched) ball.x = paddle.x + paddle.w/2;
  }

  function onStripDown(e) {
    stripDragging = true;
    ball.launched = true; // start when user interacts with the strip
    movePaddleWithStrip(e.clientX);
    document.body.style.userSelect = 'none';
  }
  function onStripMove(e) {
    if (!stripDragging) return;
    movePaddleWithStrip(e.clientX);
  }
  function onStripUp() {
    stripDragging = false;
    document.body.style.userSelect = 'auto';
  }

  dragStrip.addEventListener('pointerdown', onStripDown);
  window.addEventListener('pointermove', onStripMove);
  window.addEventListener('pointerup', onStripUp);

  </script>
</body>
</html>
