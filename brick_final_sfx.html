<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Jason's Brick Breaker Game — 2025</title>
  <style>
    :root{
      --bg:#0e1014; --fg:#e6e9ef; --muted:#a3a3a3;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background: radial-gradient(1200px 800px at 70% 20%, #161a22, var(--bg));
      color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      overflow:hidden; touch-action:none;
    }
    #wrap{position:relative;width:100vw;height:100vh}
    canvas{display:block;width:100%;height:100%}
    .hud{position:absolute;inset:0;pointer-events:none;padding:12px}
    .row{display:flex;gap:8px}
    .chip{pointer-events:auto;display:inline-flex;align-items:center;gap:6px;padding:6px 10px;
      border-radius:999px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);backdrop-filter:blur(6px);-webkit-backdrop-filter:blur(6px);font-weight:700}
    .chip small{font-weight:500;color:var(--muted)}
    .overlay{position:absolute;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.35);backdrop-filter:blur(4px)}
    .start-card{display:flex;flex-direction:column;align-items:center;gap:12px;padding:20px 22px;
      background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.12);border-radius:18px;box-shadow:0 10px 30px rgba(0,0,0,.3);text-align:center}
    .game-title{font-size:clamp(22px,6vw,44px);font-weight:900;line-height:1.05;
      background:linear-gradient(90deg,#7dd3fc,#a78bfa,#f472b6);-webkit-background-clip:text;background-clip:text;color:transparent;
      text-shadow:0 0 20px rgba(167,139,250,.18)}
    .year-badge{letter-spacing:.25em;color:#cbd5e1}
    .hint{color:var(--muted)}
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game"></canvas>
    <div class="hud">
      <div class="row">
        <div class="chip">Score&nbsp;<span id="score">0</span></div>
        <div class="chip"><small>Best</small>&nbsp;<span id="bestScore">0</span></div>
        <div class="chip"><small>Level</small>&nbsp;<span id="level">1</span></div>
        <div class="chip"><small>Lives</small>&nbsp;<span id="lives">3</span></div>
      </div>
    </div>
    <div class="overlay" id="startOverlay">
      <div class="start-card">
        <div class="game-title">Jason's Brick Breaker Game</div>
        <div class="year-badge">2025</div>
        <div class="hint">화면을 탭하거나 드래그하여 시작하세요</div>
      </div>
    </div>
  </div>

  <script>
  // ====== Setup ======
  const DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const hud = {
    score: document.getElementById('score'),
    best: document.getElementById('bestScore'),
    level: document.getElementById('level'),
    lives: document.getElementById('lives'),
  };
  const startOverlay = document.getElementById('startOverlay');

  // ====== Audio (Web Audio API) ======
  let audioCtx = null;
  function ensureAudio(){
    if (!audioCtx) {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (Ctx) audioCtx = new Ctx();
    }
    return audioCtx;
  }
  function beep({freq=600, dur=0.06, type='sine', vol=0.18, glide=0}={}){
    try{
      if (!ensureAudio()) return;
      const t0 = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, t0);
      if (glide) osc.frequency.linearRampToValueAtTime(Math.max(40, freq+glide), t0 + dur*0.9);
      gain.gain.setValueAtTime(0, t0);
      gain.gain.linearRampToValueAtTime(vol, t0 + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, t0 + dur);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(t0); osc.stop(t0 + dur + 0.02);
    }catch(e){}
  }
  function sfxWall(){ beep({freq:760, dur:0.035, type:'square', vol:0.14}); }
  function sfxPaddle(){ beep({freq:640, dur:0.04, type:'triangle', vol:0.16}); }
  function sfxBrick(){ beep({freq:520, dur:0.06, type:'triangle', vol:0.20, glide:-80}); }
  function sfxPower(){ beep({freq:880, dur:0.12, type:'sine', vol:0.16, glide:+120}); }
  function sfxLose(){ beep({freq:220, dur:0.22, type:'sawtooth', vol:0.18, glide:-140}); }
  function sfxLevel(){ beep({freq:660, dur:0.10, type:'sine', vol:0.16}); setTimeout(()=>beep({freq:880, dur:0.10, type:'sine', vol:0.16}), 50); }


  let W=0,H=0,running=false,paused=false;

  function resize(){
    W = Math.floor(window.innerWidth * DPR);
    H = Math.floor(window.innerHeight * DPR);
    canvas.width = W; canvas.height = H;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    if (!running) draw();
  }
  window.addEventListener('resize', resize);

  // ====== State ======
  let bestScore = Number(localStorage.getItem('bb_best')||0); hud.best.textContent = bestScore;
  const state = {score:0, level:1, lives:3};

  const paddle = {w:0,h:0,x:0,y:0,speed:0, baseW:0};
  const ball = {r:0, x:0, y:0, dx:0, dy:0, launched:false};

  let bricks = [];
  const brickConf = {rows:5, cols:8, marginX:18, marginY:12, padTop:90, padSide:14, h:18};

  // Power-ups
  let powerUps = []; // {type:'heart'|'turtle', x,y, vy, r}
  let scheduledDrops = []; // [{delayMs, type}]
  let timeMs = 0;
  let paddleBuffUntil = 0;

  function layoutGame(){
    paddle.baseW = Math.max(110, Math.min(260, Math.floor(W*0.18)));
    paddle.w = paddle.baseW;
    paddle.h = Math.floor(14*DPR);
    paddle.x = (W - paddle.w)/2;
    paddle.y = H - Math.floor(60*DPR);
    paddle.speed = Math.floor(8*DPR + state.level*0.6);

    ball.r = Math.floor(7*DPR);
    resetBall(false);

    const padSide = Math.floor(brickConf.padSide * DPR);
    const padTop  = Math.floor(brickConf.padTop * DPR);
    const mX = Math.floor(brickConf.marginX * DPR);
    const mY = Math.floor(brickConf.marginY * DPR);
    const h  = Math.floor(brickConf.h * DPR);

    const cols = Math.max(6, Math.min(11, brickConf.cols));
    const rows = Math.max(4, Math.min(9, brickConf.rows + (state.level>1 ? 1 : 0)));

    const totalMargin = (cols - 1) * mX + padSide * 2;
    const w = Math.floor((W - totalMargin) / cols);

    bricks = [];
    for (let r=0;r<rows;r++){
      for (let c=0;c<cols;c++){
        bricks.push({x: padSide + c*(w+mX), y: padTop + r*(h+mY), w, h, hit:false, hp:1 + Math.floor((state.level-1)/2)});
      }
    }
  }

  function resetBall(withLaunch=false){
    ball.x = paddle.x + paddle.w/2;
    ball.y = paddle.y - 18*DPR;
    const base = 4.0 + state.level*0.25;
    const angle = (-Math.PI/3) + (Math.random()*Math.PI/6);
    const spd = base * DPR;
    ball.dx = Math.cos(angle) * spd;
    ball.dy = Math.sin(angle) * spd;
    ball.launched = withLaunch;
  }

  // Power-ups scheduling & behavior
  function schedulePowerUps(){
    scheduledDrops = [];
    const rnd = (min,max)=>Math.floor(min + Math.random()*(max-min));
    // one drop per level, randomly choose heart or turtle
    const type = (Math.random()<0.5) ? 'heart' : 'turtle';
    scheduledDrops.push({delayMs:rnd(3000,15000), type});
  }
  function dropPowerUp(type){
    const r = 10*DPR;
    const x = Math.max(r, Math.min(W - r, Math.random()*W));
    powerUps.push({type, x, y: -r, vy: 3.5*DPR, r});
  }
  function applyPowerUp(pu){
    if (pu.type==='heart'){
      paddleBuffUntil = timeMs + 15000;
      paddle.w = Math.min(paddle.w*2, Math.floor(W*0.5));
    } else { // turtle
      const base = (4.0 + state.level*0.25) * DPR;
      const dir = Math.atan2(ball.dy, ball.dx);
      ball.dx = Math.cos(dir) * base;
      ball.dy = Math.sin(dir) * base;
    }
  }

  // ====== Input ======
  let dragging=false;
  function movePaddleToClient(clientX){
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) * DPR;
    const target = Math.max(0, Math.min(W - paddle.w, x - paddle.w/2));
    paddle.x = target;
    if (!ball.launched) ball.x = paddle.x + paddle.w/2;
  }
  function onPointerDown(e){ dragging=true; ball.launched=true; movePaddleToClient(e.clientX); }
  function onPointerMove(e){ if(dragging) movePaddleToClient(e.clientX); }
  function onPointerUp(){ dragging=false; }
  canvas.addEventListener('pointerdown', onPointerDown);
  canvas.addEventListener('pointermove', onPointerMove);
  window.addEventListener('pointerup', onPointerUp);

  // ====== Loop ======
  let lastTime=0;
  function loop(ts){
    if(!running) return;
    const dt = Math.min(32, ts - lastTime); lastTime = ts;
    if(!paused) update(dt/16.666);
    draw();
    requestAnimationFrame(loop);
  }

  function update(dt){
    timeMs += dt*16.666;

    // Paddle keyboard (optional)
    // (mobile primarily uses touch; left/right keys also work)
    if (keys.left) paddle.x = Math.max(0, paddle.x - paddle.speed*dt);
    if (keys.right) paddle.x = Math.min(W - paddle.w, paddle.x + paddle.speed*dt);
    if (!ball.launched) ball.x = paddle.x + paddle.w/2;

    if (ball.launched){
      ball.x += ball.dx * dt; ball.y += ball.dy * dt;

      // walls
      if (ball.x < ball.r) { ball.x = ball.r; ball.dx *= -1; sfxWall(); }
      if (ball.x > W - ball.r) { ball.x = W - ball.r; ball.dx *= -1; sfxWall(); }
      if (ball.y < ball.r + 8*DPR) { ball.y = ball.r + 8*DPR; ball.dy *= -1; sfxWall(); }

      // bottom
      if (ball.y > H + ball.r){ sfxLose();
        state.lives--; hud.lives.textContent = state.lives;
        if (state.lives <= 0) { endGame(); return; }
        resetBall(false);
      }

      // paddle
      if (ball.y + ball.r >= paddle.y && ball.y - ball.r <= paddle.y + paddle.h &&
          ball.x >= paddle.x && ball.x <= paddle.x + paddle.w && ball.dy > 0){
        ball.y = paddle.y - ball.r;
        const hitPos = (ball.x - paddle.x) / paddle.w; // 0..1
        const angle = (Math.PI*0.75) * (hitPos - 0.5);
        const spd = Math.min(12*DPR, Math.hypot(ball.dx, ball.dy) * 1.03 + 0.2*DPR);
        ball.dx = Math.sin(angle) * spd;
        ball.dy = -Math.cos(angle) * spd;
        sfxPaddle();
      }

      // bricks
      for (const br of bricks){
        if (br.hit) continue;
        if (ball.x + ball.r < br.x || ball.x - ball.r > br.x + br.w || ball.y + ball.r < br.y || ball.y - ball.r > br.y + br.h) continue;
        const overlapX = Math.min(ball.x + ball.r - br.x, br.x + br.w - (ball.x - ball.r));
        const overlapY = Math.min(ball.y + ball.r - br.y, br.y + br.h - (ball.y - ball.r));
        if (overlapX < overlapY) ball.dx *= -1; else ball.dy *= -1;
        br.hp--; if (br.hp<=0){ br.hit=true; state.score += 10; hud.score.textContent = state.score; sfxBrick(); }
        break;
      }

      // power-up schedule
      for (let i=scheduledDrops.length-1;i>=0;i--){
        scheduledDrops[i].delayMs -= dt*16.666;
        if (scheduledDrops[i].delayMs <= 0){
          dropPowerUp(scheduledDrops[i].type);
          scheduledDrops.splice(i,1);
        }
      }
      // power-up fall & collect
      for (let i=powerUps.length-1;i>=0;i--){
        const pu = powerUps[i];
        pu.y += pu.vy * dt;
        if (pu.y + pu.r >= paddle.y && pu.y - pu.r <= paddle.y + paddle.h &&
            pu.x >= paddle.x && pu.x <= paddle.x + paddle.w){
          applyPowerUp(pu);
          sfxPower();
          powerUps.splice(i,1);
          continue;
        }
        if (pu.y - pu.r > H) powerUps.splice(i,1);
      }
      // buff expiry
      if (paddleBuffUntil && timeMs > paddleBuffUntil){
        paddleBuffUntil = 0;
        paddle.w = paddle.baseW;
      }

      // level clear
      if (bricks.every(b=>b.hit)){
        state.level++; hud.level.textContent = state.level; sfxLevel();
        layoutGame();
        resetBall(false);
        schedulePowerUps();
      }
    }
  }

  function draw(){
    ctx.clearRect(0,0,W,H);

    // background grid
    ctx.save();
    const g = 24*DPR; ctx.strokeStyle='rgba(255,255,255,0.04)'; ctx.lineWidth=1;
    ctx.beginPath();
    for (let x=0;x<=W;x+=g){ ctx.moveTo(x,0); ctx.lineTo(x,H); }
    for (let y=0;y<=H;y+=g){ ctx.moveTo(0,y); ctx.lineTo(W,y); }
    ctx.stroke(); ctx.restore();

    // bricks
    for (const br of bricks){
      if (br.hit) continue;
      const c1 = `hsl(${200 + (br.y%120)}, 80%, 62%)`;
      roundRect(ctx, br.x, br.y, br.w, br.h, 6*DPR, 'rgba(255,255,255,0.08)', c1);
    }

    // paddle
    roundRect(ctx, paddle.x, paddle.y, paddle.w, paddle.h, 8*DPR, 'rgba(255,255,255,0.08)', '#9fb6ff');

    // ball
    ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
    ctx.fillStyle='#67e8f9'; ctx.fill(); ctx.strokeStyle='rgba(255,255,255,0.25)'; ctx.stroke();

    // power-ups (heart/turtle)
    for (const pu of powerUps){
      ctx.save(); ctx.translate(pu.x, pu.y);
      if (pu.type==='heart'){
        const r = pu.r; ctx.fillStyle = '#ff6b6b';
        ctx.beginPath();
        ctx.moveTo(0, r*0.6);
        ctx.bezierCurveTo(r*1.2, -r*0.2,  r*0.6, -r*1.2, 0, -r*0.2);
        ctx.bezierCurveTo(-r*0.6, -r*1.2, -r*1.2, -r*0.2, 0, r*0.6);
        ctx.closePath(); ctx.fill();
      } else { // turtle
        const r = pu.r; ctx.fillStyle = '#34d399';
        ctx.beginPath(); ctx.ellipse(0,0,r*1.0,r*0.8,0,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(r*1.1,0,r*0.25,0,Math.PI*2); ctx.fill();
        ctx.fillRect(-r*0.9,-r*0.7,r*0.25,r*0.25);
        ctx.fillRect( r*0.65,-r*0.7,r*0.25,r*0.25);
        ctx.fillRect(-r*0.9, r*0.45,r*0.25,r*0.25);
        ctx.fillRect( r*0.65, r*0.45,r*0.25,r*0.25);
      }
      ctx.restore();
    }
  }

  function roundRect(ctx,x,y,w,h,r,fill,stroke){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
    if (fill){ ctx.fillStyle=fill; ctx.fill(); }
    if (stroke){ ctx.strokeStyle=stroke; ctx.lineWidth=2; ctx.stroke(); }
  }

  function endGame(){
    running=false;
    if (state.score>bestScore){ bestScore=state.score; localStorage.setItem('bb_best',bestScore); }
    alert(`Game Over\\nScore: ${state.score}\\nBest: ${bestScore}`);
    startOverlay.style.display='grid';
  }

  // ====== Keyboard (optional) ======
  const keys = {left:false, right:false};
  window.addEventListener('keydown',e=>{ if(e.key==='ArrowLeft'||e.key==='a')keys.left=true; if(e.key==='ArrowRight'||e.key==='d')keys.right=true; if(e.key===' ') ball.launched=true; });
  window.addEventListener('keyup',e=>{ if(e.key==='ArrowLeft'||e.key==='a')keys.left=false; if(e.key==='ArrowRight'||e.key==='d')keys.right=false; });

  // ====== Start / Init ======
  function startGame(){
    state.score=0; state.level=1; state.lives=3;
    hud.score.textContent=0; hud.level.textContent=1; hud.lives.textContent=3;
    startOverlay.style.display='none';
    layoutGame();
    schedulePowerUps();
    running=true; paused=false;
    lastTime=performance.now();
    requestAnimationFrame(loop);
  }

  // Start on first pointer anywhere
  window.addEventListener('pointerdown', () => {
    try{ if(ensureAudio() && audioCtx.state==='suspended') audioCtx.resume(); }catch(e){}

    if (!running) startGame();
  }, {once:true});

  resize(); draw();
  </script>
</body>
</html>
